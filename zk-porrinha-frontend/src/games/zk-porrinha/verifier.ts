import { Client as VerifierClient, networks } from './noir_verifier_bindings/src';
import { rpc } from '@stellar/stellar-sdk';

const RPC_URL = 'https://soroban-testnet.stellar.org';
const VERIFIER_CONTRACT_ID = 'CDQOXWXGBFPZ3LVYRF56AZWOHBMRJIH7FS5RF5X25TJPABUZKO463DS6';

/**
 * Initialize the Noir verifier client
 */
export function getVerifierClient(publicKey?: string) {
  const rpcServer = new rpc.Server(RPC_URL);
  
  return new VerifierClient({
    ...networks.testnet,
    rpcUrl: RPC_URL,
    networkPassphrase: networks.testnet.networkPassphrase,
    contractId: VERIFIER_CONTRACT_ID,
    publicKey,
  });
}

/**
 * Verify a Noir proof on-chain using the Stellar verifier contract
 * @param proof - The proof bytes generated by Noir
 * @param publicInputs - Array of public inputs (commitments, total_sum, etc.)
 * @param publicKey - The user's public key (for signing)
 * @returns true if proof is valid, false otherwise
 */
export async function verifyProofOnChain(
  proof: Uint8Array,
  publicInputs: Uint8Array[],
  publicKey: string
): Promise<boolean> {
  try {
    const client = getVerifierClient(publicKey);
    
    // Convert Uint8Array to Buffer for the contract
    const proofBuffer = Buffer.from(proof);
    const publicInputsBuffers = publicInputs.map(input => Buffer.from(input));
    
    console.log('üîç Verifying proof on-chain...');
    console.log('Proof size:', proof.length, 'bytes');
    console.log('Public inputs:', publicInputsBuffers.length);
    
    // Call the verify function
    const tx = await client.verify({
      proof: proofBuffer,
      public_inputs: publicInputsBuffers,
    });
    
    const result = await tx.simulate();
    
    console.log('‚úÖ Verification result:', result.result);
    
    return result.result || false;
  } catch (error) {
    console.error('‚ùå Verification failed:', error);
    return false;
  }
}

/**
 * Register a circuit hash with the verifier contract
 * This allows the contract to validate which circuits are trusted
 */
export async function registerCircuit(
  circuitHash: Uint8Array,
  name: string,
  version: number,
  publicKey: string
): Promise<boolean> {
  try {
    const client = getVerifierClient(publicKey);
    
    const circuitHashBuffer = Buffer.from(circuitHash);
    
    console.log('üìù Registering circuit:', name, 'v' + version);
    
    const tx = await client.register_circuit({
      circuit_hash: circuitHashBuffer,
      name: name.substring(0, 9), // Symbol max length is 9
      version,
    });
    
    const result = await tx.signAndSend();
    
    console.log('‚úÖ Circuit registered:', result);
    
    return true;
  } catch (error) {
    console.error('‚ùå Circuit registration failed:', error);
    return false;
  }
}

/**
 * Get circuit info from the verifier contract
 */
export async function getCircuitInfo(
  circuitHash: Uint8Array,
  publicKey?: string
): Promise<{ circuit_hash: Buffer; name: string; version: number } | null> {
  try {
    const client = getVerifierClient(publicKey);
    
    const circuitHashBuffer = Buffer.from(circuitHash);
    
    const tx = await client.get_circuit({
      circuit_hash: circuitHashBuffer,
    });
    
    const result = await tx.simulate();
    
    return result.result || null;
  } catch (error) {
    console.error('‚ùå Failed to get circuit info:', error);
    return null;
  }
}

/**
 * Verify a proof with circuit hash validation
 * This is the recommended method as it ensures the circuit is registered
 */
export async function verifyProofWithCircuit(
  proof: Uint8Array,
  publicInputs: Uint8Array[],
  circuitHash: Uint8Array,
  publicKey: string
): Promise<boolean> {
  try {
    const client = getVerifierClient(publicKey);
    
    const proofBuffer = Buffer.from(proof);
    const publicInputsBuffers = publicInputs.map(input => Buffer.from(input));
    const circuitHashBuffer = Buffer.from(circuitHash);
    
    console.log('üîç Verifying proof with circuit validation...');
    
    const tx = await client.verify_with_circuit({
      proof: proofBuffer,
      public_inputs: publicInputsBuffers,
      circuit_hash: circuitHashBuffer,
    });
    
    const result = await tx.simulate();
    
    console.log('‚úÖ Verification result:', result.result);
    
    return result.result || false;
  } catch (error) {
    console.error('‚ùå Verification with circuit failed:', error);
    return false;
  }
}
