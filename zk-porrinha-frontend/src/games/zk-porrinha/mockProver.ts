/**
 * Mock ZK Prover for Development
 * 
 * This module provides a mock implementation of the ZK prover for development purposes.
 * It generates deterministic "fake" proofs that allow testing the game flow without
 * requiring actual zero-knowledge proof generation in the browser.
 * 
 * PRODUCTION NOTE: Replace this with real noir.js integration when ready for production.
 */

import { Buffer } from "buffer";
import { xdr } from "@stellar/stellar-sdk";

/**
 * Generate a mock commitment using a simple deterministic hash
 * In production, this would be Poseidon2(hand || parity || jackpot_guess || salt)
 */
function generateMockCommitment(
  hand: number,
  parity: number,
  jackpotGuess: number,
  salt: string
): Buffer {
  // Simple deterministic "hash" for development
  // Using a mixing function to create a 32-byte value
  const input = `${hand}-${parity}-${jackpotGuess}-${salt}`;
  const hash = Buffer.alloc(32);
  
  for (let i = 0; i < input.length; i++) {
    hash[i % 32] ^= input.charCodeAt(i);
  }
  
  // Add some deterministic mixing
  for (let i = 0; i < 32; i++) {
    hash[i] = (hash[i] * 7 + i * 13) % 256;
  }
  
  return hash;
}

/**
 * Generate a mock proof buffer
 * In production, this would be a real zero-knowledge proof generated by noir.js
 */
function generateMockProofBuffer(
  hand: number,
  parity: number,
  jackpotGuess: number,
  salt: string,
  jackpotAccumulated: number
): Buffer {
  // Create a deterministic "proof" that encodes the private data
  // In a real ZK proof, this would be indistinguishable from random data
  const proof = Buffer.alloc(128); // Typical proof size
  
  const input = `${hand}-${parity}-${jackpotGuess}-${salt}-${jackpotAccumulated}`;
  
  for (let i = 0; i < input.length; i++) {
    proof[i % 128] ^= input.charCodeAt(i);
  }
  
  // Add deterministic mixing to make it look like random data
  for (let i = 0; i < 128; i++) {
    proof[i] = (proof[i] * 11 + i * 17 + hand * 3 + parity * 5) % 256;
  }
  
  return proof;
}

/**
 * Generate a random salt for the commitment
 */
export function generateSalt(): string {
  // Generate a random 32-byte hex string (64 hex chars)
  // Contract expects BytesN<32>
  const bytes = new Uint8Array(32);
  crypto.getRandomValues(bytes);
  return Buffer.from(bytes).toString("hex");
}

/**
 * Mock prover interface
 * Simulates what a real noir.js prover would do
 */
export interface MockProverInput {
  hand: number; // 0-5
  parity: number; // 1 (odd) or 0 (even)
  jackpotGuess: number; // 0-99
  salt?: string; // Optional, will be generated if not provided
  jackpotAccumulated: number; // Current jackpot value
}

export interface MockProverOutput {
  commitment: xdr.ScVal; // BytesN<32> commitment
  proof: xdr.ScVal; // Bytes proof
  salt: string; // Salt used (for reveal phase)
}

/**
 * Generate a mock proof and commitment
 * 
 * In production, this would:
 * 1. Load the circuit from circuits/zk-porrinha/target/zk_porrinha.json
 * 2. Create a noir.js prover instance
 * 3. Generate real zero-knowledge proof using noir.js
 * 4. Return the proof and commitment
 */
export async function generateMockProof(
  input: MockProverInput
): Promise<MockProverOutput> {
  const { hand, parity, jackpotGuess, jackpotAccumulated } = input;
  
  // Validate inputs
  if (hand < 0 || hand > 5) {
    throw new Error("Hand value must be between 0 and 5");
  }
  if (parity !== 0 && parity !== 1) {
    throw new Error("Parity must be 1 (odd) or 0 (even)");
  }
  if (jackpotGuess < 0 || jackpotGuess > 99) {
    throw new Error("Jackpot guess must be between 0 and 99");
  }
  
  // In development/mock mode, we don't enforce jackpot validation
  // In production with real ZK circuit, this would be enforced by the circuit itself
  // The circuit would only generate a valid proof if jackpotGuess === jackpotAccumulated % 100
  const expectedGuess = jackpotAccumulated % 100;
  if (jackpotGuess !== expectedGuess) {
    console.warn(
      `[MockProver] Warning: Jackpot guess (${jackpotGuess}) doesn't match accumulated % 100 (${expectedGuess}). ` +
      `In production, the ZK circuit would reject this.`
    );
    // Don't throw - allow it in mock mode for testing
  }
  
  // Generate or use provided salt
  const salt = input.salt || generateSalt();
  
  // Simulate async proof generation (in real noir.js this takes 1-5 seconds)
  await new Promise((resolve) => setTimeout(resolve, 100));
  
  // Generate mock commitment
  const commitmentBuffer = generateMockCommitment(hand, parity, jackpotGuess, salt);
  
  // Generate mock proof
  const proofBuffer = generateMockProofBuffer(
    hand,
    parity,
    jackpotGuess,
    salt,
    jackpotAccumulated
  );
  
  // Convert to Stellar XDR ScVal format
  const commitment = xdr.ScVal.scvBytes(commitmentBuffer);
  const proof = xdr.ScVal.scvBytes(proofBuffer);
  
  console.log(`[MockProver] Generated mock proof for hand=${hand}, parity=${parity}, jackpot=${jackpotGuess}`);
  
  return {
    commitment,
    proof,
    salt,
  };
}

/**
 * Recompute commitment from reveal data
 * Used in the reveal phase to verify the commitment matches
 */
export function recomputeCommitment(
  hand: number,
  parity: number,
  jackpotGuess: number,
  salt: string
): Buffer {
  return generateMockCommitment(hand, parity, jackpotGuess, salt);
}
