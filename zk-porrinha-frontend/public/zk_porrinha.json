{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":135328915247813272,"abi":{"parameters":[{"name":"hand_value","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"parity_guess","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"total_guess","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"jackpot_guess","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"jackpot_accumulated","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"}],"return_type":{"abi_type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/9VZXW/aMBR1ErKWr1IKrPRjU7a3vdkkgWRP/BUYQatERTVlq/bnq2HhO4xx+1COablSdIM/ro+P73ES47G1fV5d39S9t7oC5aVFRplnKfMtZYGlLFxdY+WZ6mcajTtWPubDJClGg0LEYsIH+TRLeZJOh5nIRJqls0EWx0WWZKN8mo94LpK4EPM0j+d8bXos/joTyqcWuKjYXOeirnzDXJCGIlW3wCFhr4w1ULFEHYir4Wgh0QlX3x/nf7yHFIqH41dY4DoRSlP5MyKEhCILIgMAWigewwmlCcR15mgh0QnXZMcpFB/H78QC14lQWsqfEyEkFFkQGQDQQvEZTigtIK5zRwuJTrgWO06hBDB+h7EFrhOhtJW/IEJIKLIgMgCghRIwnFDaQFwXjhYSnXBt9jZC4fuZCHGxuAUuKPYw0bnoKN8lQkgosuK7USYbnRigfDCJXWAi9WC4xA+dh56FhwDMQwjgoZhLy2cdIKdd5ibJXW7CfD+D5uRHIH8h2xzmmIbe3JC4dbyXLgFfOojbByaDq3n3NYJBcbfEit30108kFKdXDJuotOnLuBHbNvSmj9y0roCcXjvi9JptTpflQ6qixiBNPLHNBvek9aH7irqnfjer63Z1fWLr0/CKsV7ol5UPQI5v2GG0+g5O4snEyZHMGXCoSiZOj2TOgPMxMlE90Jz5fiZqQP76DLtn0l4WavOnf+0CVe9pbaid3KOkzmTeyXWose2v4Ui7/6L8pCyL+4cyKpfR/e9Fefew+Bs93pU/o+Wf4td8sXyUjb5qHW93O05mM6MPjXqqfFX5mjYb4BNwQPHrbuJz8xNQn4s+LhnNv2Lp5z3z2zf8S21f+gxoWuooZsdSVjV8V4uHfEuh+D038a1r1NXue8Y8dZ7HIAwUj94WQ7ZrvlFHbU2teHh8O3/zBZaxyPRcofp/HzvZEIAgAAA=","debug_symbols":"ldXRisMgEAXQf/E5D+po1PzKspSkTYogpiTpwhL67+u2FVoRyn1zHI8wXMSdncbhej74OM0r6752FuZjv/k5pmpn+r61Xvr4X61bv2ysk1I1bIyntCJ3a9jkw8g6w2/fDWtRYFBgUeCqQFMG6dQ7EBwWAhYSFlQVNg9OXJRCwULDooVFNXESOgtSpbCwcKiQHBbVzKnNCZK1pZCwIFgoWGhYtLCoZq6MeQotdCksLBwqiMOimrkReXJD5aslCQv6IFRbCgWLauaOZ+HoffJUDIsPwZ8Pr99D2v7pF98PYXyW0zUeX7rb7+XRSVf8AQ==","file_map":{"70":{"source":"\n\nuse std::hash::poseidon2_permutation;\n\nfn main(\n    hand_value: u32,\n    parity_guess: u32,\n    total_guess: u32,\n    jackpot_guess: u32,\n    salt: Field,\n    jackpot_accumulated: pub u64\n) -> pub [Field; 5] {\n\n    assert(hand_value <= 5);\n    assert(parity_guess <= 1);\n    assert(total_guess <= 10);\n    assert(jackpot_guess <= 99);\n\n    let jackpot_secret = jackpot_accumulated % 100;\n    // jackpot_hit flag: 1 if correct, 0 otherwise\n    let jackpot_hit_flag: u32 = if (jackpot_guess as u64 == jackpot_secret) { 1 } else { 0 };\n    // do NOT assert equality - we want the circuit to allow both correct and incorrect guesses\n    // so the proof can reveal jackpot_hit as 0/1.\n    \n    let combined_guess = (total_guess * 100 + jackpot_guess) as Field;\n    let inputs = [\n        hand_value as Field,\n        parity_guess as Field,\n        combined_guess,\n        salt\n    ];\n    let hash_result = poseidon2_permutation(inputs, 4);\n    let commitment = hash_result[0];\n\n    // Return commitment, revealed hand/parity/total and jackpot_hit (0/1)\n    [commitment, hand_value as Field, parity_guess as Field, total_guess as Field, jackpot_hit_flag as Field]\n}\n\n#[test]\nfn test_valid_proof() {\n    // Valid inputs - ALL PRIVATE\n    let hand: u32 = 3;               // PRIVATE: hand\n    let parity: u32 = 1;             // PRIVATE: even\n    let total: u32 = 7;              // PRIVATE: total guess\n    let jackpot_guess: u32 = 42;     // PRIVATE: jackpot guess\n    let salt: Field = 123456789;     // PRIVATE: salt\n    let jackpot_accumulated: u64 = 1042; // PUBLIC: 1042 % 100 = 42\n    \n    // Call main and get outputs\n    let outputs = main(hand, parity, total, jackpot_guess, salt, jackpot_accumulated);\n    \n    // Verify outputs\n    // outputs[0] = commitment (should be non-zero)\n    // outputs[1] = hand (should be 3)\n    // outputs[2] = parity (should be 1)\n    // outputs[3] = total_guess (should be 7)\n    assert(outputs[0] != 0);\n    assert(outputs[1] == 3);\n    assert(outputs[2] == 1);\n    assert(outputs[3] == 7);\n}\n\n#[test(should_fail)]\nfn test_invalid_hand() {\n    let hand: u32 = 6; // Invalid: > 5\n    let parity: u32 = 1;\n    let total: u32 = 7;\n    let jackpot_guess: u32 = 42;\n    let salt: Field = 123456789;\n    let jackpot_accumulated: u64 = 1042;\n    \n    let _ = main(hand, parity, total, jackpot_guess, salt, jackpot_accumulated);\n}\n\n#[test(should_fail)]\nfn test_invalid_parity() {\n    let hand: u32 = 3;\n    let parity: u32 = 2; // Invalid: must be 0 or 1\n    let total: u32 = 7;\n    let jackpot_guess: u32 = 42;\n    let salt: Field = 123456789;\n    let jackpot_accumulated: u64 = 1042;\n    \n    let _ = main(hand, parity, total, jackpot_guess, salt, jackpot_accumulated);\n}\n\n#[test(should_fail)]\nfn test_invalid_total() {\n    let hand: u32 = 3;\n    let parity: u32 = 1;\n    let total: u32 = 11; // Invalid: > 10\n    let jackpot_guess: u32 = 42;\n    let salt: Field = 123456789;\n    let jackpot_accumulated: u64 = 1042;\n    \n    let _ = main(hand, parity, total, jackpot_guess, salt, jackpot_accumulated);\n}\n\n#[test(should_fail)]\nfn test_wrong_jackpot_guess() {\n    let hand: u32 = 3;\n    let parity: u32 = 1;\n    let total: u32 = 7;\n    let jackpot_guess: u32 = 43; // Wrong: should be 42\n    let salt: Field = 123456789;\n    let jackpot_accumulated: u64 = 1042; // 1042 % 100 = 42\n    \n    let _ = main(hand, parity, total, jackpot_guess, salt, jackpot_accumulated);\n}\n","path":"/l/disk0/fnunes/Documentos/me/Stellar-Game-Studio/circuits/zk-porrinha/src/main.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}