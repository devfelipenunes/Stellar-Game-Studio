# Stellar Game Studio

Development Tools For Web3 Game Builders On Stellar.

Ecosystem ready game templates and examples ready to scaffold into into your development workflow

**Start here:** [Stellar Game Studio](https://jamesbachini.github.io/Stellar-Game-Studio/)


## Why this exists

Stellar Game Studio is a toolkit for shipping web3 games quickly and efficiently. It pairs Stellar smart contract patterns with a ready-made frontend stack and deployment scripts, so you can focus on game design and gameplay mechanics.

## What you get

- Battle-tested Soroban patterns for two-player games
- A ecosystem ready mock game hub contract that standardizes lifecycle and scoring
- Deterministic randomness guidance and reference implementations
- One-command scaffolding for contracts + standalone frontend
- Testnet setup that generates wallets, deploys contracts, and wires bindings
- A production build flow that outputs a deployable frontend

## Quick Start (Dev)

```bash
# Fork the repo, then:
git clone https://github.com/jamesbachini/Stellar-Game-Studio
cd Stellar-Game-Studio
bun install

# Build + deploy contracts to testnet, generate bindings, write .env
bun run setup

# Scaffold a game + dev frontend
bun run create my-game

# Run the standalone dev frontend with testnet wallet switching
bun run dev:game my-game
```

## Publish (Production)

```bash
# Export a production container and build it (uses CreitTech wallet kit v2)
bun run publish my-game --build

# Update runtime config in the output
# dist/my-game-frontend/public/game-studio-config.js
```

## Project Structure

```
‚îú‚îÄ‚îÄ contracts/               # Soroban contracts for games + mock Game Hub
‚îú‚îÄ‚îÄ template_frontend/       # Standalone number-guess example frontend used by create
‚îú‚îÄ‚îÄ <game>-frontend/         # Standalone game frontend (generated by create)
‚îú‚îÄ‚îÄ sgs_frontend/            # Documentation site (builds to docs/)
‚îú‚îÄ‚îÄ scripts/                 # Build & deployment automation
‚îî‚îÄ‚îÄ bindings/                # Generated TypeScript bindings
```

## Commands

```bash
bun run setup                         # Build + deploy testnet contracts, generate bindings
bun run build [game-name]             # Build all or selected contracts
bun run deploy [game-name]            # Deploy all or selected contracts to testnet
bun run bindings [game-name]          # Generate bindings for all or selected contracts
bun run create my-game                # Scaffold contract + standalone frontend
bun run dev:game my-game              # Run a standalone frontend with dev wallet switching
bun run publish my-game --build       # Export + build production frontend
```

## Ecosystem Constraints

- Every game must call `start_game` and `end_game` on the Game Hub contract:
  Testnet: CB4VZAT2U3UC6XFK3N23SKRF2NDCMP3QHJYMCHHFMZO7MRQO6DQ2EMYG
- Game Hub enforces exactly two players per session.
- Keep randomness deterministic between simulation and submission.
- Prefer temporary storage with a 30-day TTL for game state.

## Notes

- Dev wallets are generated during `bun run setup` and stored in the root `.env`.
- Production builds read runtime config from `public/game-studio-config.js`.

Interface for game hub:
```
#[contractclient(name = "GameHubClient")]
pub trait GameHub {
    fn start_game(
        env: Env,
        game_id: Address,
        session_id: u32,
        player1: Address,
        player2: Address,
        player1_points: i128,
        player2_points: i128,
    );

    fn end_game(
      env: Env,
      session_id: u32,
      player1_won: bool
    );
}
```

## üîê Zero-Knowledge Gaming

This repository features **ZK-Porrinha**, a production-ready example of Zero-Knowledge proofs in Stellar gaming using Protocol 25 (X-Ray) primitives.

### Why ZK Matters for Games

Traditional blockchain games struggle with hidden information (poker hands, Battleship positions, simultaneous moves). ZK-Porrinha demonstrates how to build "fair by design" mechanics using:

- **BN254 elliptic curve** verification (native Soroban support)
- **Poseidon2 hash function** (ZK-friendly, Protocol 25+)
- **Noir circuits** with Barretenberg proof generation
- **Commit-reveal protocol** where players prove validity without revealing choices

### ZK-Porrinha Architecture

```
circuits/zk-porrinha/     ‚Üí Noir circuit (validates hand 0-5, generates proof)
contracts/noir-verifier/  ‚Üí BN254 proof verifier (Soroban native ops)
contracts/zk-porrinha/    ‚Üí Game logic + on-chain verification
frontend/                 ‚Üí React + Noir.js (WASM proof generation)
```

**Game Flow:**
1. Player commits hand + proof (hand remains private)
2. Both players commit without seeing each other
3. Proofs verified on-chain ‚Üí hands revealed simultaneously
4. Winner determined fairly (impossible to cheat)

**ZK Guarantees:**
- ‚úÖ Can't see opponent's move before committing
- ‚úÖ Can't submit invalid hand values (proof fails)
- ‚úÖ Can't change move after seeing opponent (commitment binding)
- ‚úÖ Winner computed deterministically on-chain

See `contracts/zk-porrinha/README.md` and `circuits/zk-porrinha/` for implementation details.

## Studio Reference

Run the studio frontend locally (from `sgs_frontend/`):
```bash
bun run dev
```

Build docs into `docs/`:
```bash
bun --cwd=sgs_frontend run build:docs
```

## Links
https://developers.stellar.org/
https://risczero.com/
https://jamesbachini.com
https://www.youtube.com/c/JamesBachini
https://bachini.substack.com
https://x.com/james_bachini
https://www.linkedin.com/in/james-bachini/
https://github.com/jamesbachini

## üìÑ License

MIT License - see LICENSE file


**Built with ‚ù§Ô∏è for Stellar developers**
